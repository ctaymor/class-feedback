Q1: What do you think would be bet for the user to see when:
- Rotating the tablet from landscape to portrait when both
fragments are visible.

The list fragment should be hidden and the comment detail fragment
should remain visible.

-Rotating the tablet from portrait to landscape view when the
detail fragment is visible.

The list fragment and the comment detail fragment should both
be made visible.

This was successful.

Problem: I got a RuntimeException when I tried to set the ContentView.
This stumped me for a while, because the first bits of my code I 
was running into in the LogCat trace had to do with the XML files. I
couldn't see any problems in the XML files. I tried to mimic the XML
files of the Rss reader app to start, since the fragments worked
there, but that didn't help. I emailed Ellen, and she found that later
in the error trace, there was another Exception, which was quite
explicit in how to fix the problem.

Solution: Make MainActivity implement
ClassListFragment.OnCommentClickedListener. I didn't figure this out,
Ellen did. The real lesson here for me was that I need to look deeper
at the LogCat files, and not assume that the info is at the first
reference to my code after an Exception, because the RuntimeException
was caused by a ClassCastException much later in the code.

Problem:
When I clicked on the comment button for, say, Christie, Colin's
comment fragment would show up. It appeared somewhat random 
who showed up, although there was some correlation to whose 
row was at the very bottom. That was not always the case 
however.

Solution:
After much stackoverflow and google research, I figured out that
the problem was how ListView works. The rows are created only for
the visible rows, to save memory, and as one scrolls, other rows
are created (and recycled) as needed. In order to pass the 
variable into the inner class of the click listener not as a 
parameter, I made a variable which was declared in the class.
This meant that each time a row was generated, that variable 
changed to the newest person whose row had been created, but 
accessing it from the click listener gave me the wrong person.
I then knew what was the real problem.

After a lot of reading about what was really going on, this stack
overflow helped me get an idea of what the solution was, although
it was less than helpful in how to implement it.
http://stackoverflow.com/questions/19776755/ 
The solution I used turned out to be adding a tag to the button
object with the parameter of the person whose row it was, and then
in the click listener, calling the getTag method on the view which
the click listener gets passed in. That way, I had access to the proper
person inside the click listener. I found the documentation for the get
and set tag methods in Android's View class (inherited by ListView, Button,
etc)
http://developer.android.com/reference/android/view/View.html#setTag(java.lang.Object)
It also took a little playing around to figure out which view to 
attach the tag to.

I also learned that it is more efficient to use a ViewHolder
pattern for ListViews. I ran into this idea all over the place,
but this was a good resource for both understanding why it is
important and how to implement it. I used their first example
of how to use the design pattern (with a class ViewHolder) instead
of the second implementation (with a new layout class ListRow) because
I wasn't sure how to implement ListRow in the xml, and wanted to first
complete the rest of the lab before coming back to that if I had time.
http://sriramramani.wordpress.com/2012/07/25/infamous-viewholder-pattern/